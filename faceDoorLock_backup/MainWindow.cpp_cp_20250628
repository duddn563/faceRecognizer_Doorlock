// -------------------- gui/MainWindow.cpp --------------------
#include "MainWindow.hpp"
#include "ui_MainWindow.h"


// ì €ì¥ëœ ì–¼êµ´ ë§¤í•‘: label -> gray face image
map<int, vector<Mat>> storedFaces;

std::vector<UserData> storedUsers;

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)
{
		try {
				setupUi();
		} catch (const std::exception& e) {
				LOG_CRITICAL(QString("setupUi failed: %1").arg(e.what()));
				showErrorMessage("Fatal Error", "An error occurred during initialization.\nprogram will now terminate.");
				qApp->exit(-1);

		} catch (...) {
				LOG_CRITICAL("Unknown exception occurred during setupUi");
				showErrorMessage("Fatal Error", "Unknown error occurred.\nprogram will now terminate.");
				qApp->exit(-1);
		}
		
		setupQTimer();

		/*
		openCamera();

		//setupFaceRecognitionWorker();
		
		createLBPH();
		loadFaceCascade();
		loadEyesCascade();

		registerExistingUser();
		*/

		setupFdUltrasonic();
		setupDdUltrasonic();

}

void MainWindow::setupFaceRecognitionWorker() 
{
		worker = new FaceRecognizerWorker;
		workerThread = new QThread;

		worker->moveToThread(workerThread);

		connect(workerThread, &QThread::started, worker, &FaceRecognizerWorker::initialize);

		connect(worker, &FaceRecognizerWorker::recognitionResult,
						this, [](const QString &msg) {
								qDebug() << "Recognition Result:" << msg;
						});

		connect(worker, &FaceRecognizerWorker::errorOccurred,
						this, [](const QString &err) {
								qWarning() << "Worker error: " << err;
						});

		connect(workerThread, &QThread::finished, worker, &QObject::deleteLater);

		workerThread->start();
}


/*
void MainWindow::openCamera()
{
		try {
				cap.open(CAM_NUM);
				if (!cap.isOpened()) {
						showErrorMessage("Warning", "Failed to open camera.");;
						Logger::writef("[%s] Camera open was failed(cam %d)!!\n", __func__, CAM_NUM);
						return;
				}
				Logger::writef("[%s] Camera open was successfully(cam %d)!!\n", __func__, CAM_NUM);
		} catch (const cv::Exception& e) {
				LOG_CRITICAL(QString("OpenCV exception: %1").arg(e.what()));
		}
}
*/

void MainWindow::setupUi()
{
		ui = new Ui::MainWindow;
		ui->setupUi(this);

		setupCameraLabel();

		try {
				setupOverlayLabel();

		} catch (const exception& e) {
				LOG_CRITICAL(QString("exception: %1").arg(e.what()));
				showErrorMessage("Warning", "Failed to initialize overlay label");
				overlayLabel = nullptr;
		}

		setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT);

		applyStyles();
		connectSignals();

}

void MainWindow::setupCameraLabel()
{
		ui->cameraLabel->setScaledContents(true);
}

void MainWindow::setupOverlayLabel()
{
		overlayLabel = new QLabel(ui->cameraLabel);
		if (!overlayLabel) {
				throw std::runtime_error("Failed to allocate overlayLabel");
		}
		overlayLabel->setScaledContents(true);
		overlayLabel->resize(ui->cameraLabel->size());
		overlayLabel->hide();
}

void MainWindow::applyStyles()
{
    ui->statusbar->setStyleSheet(STATUS_BAR_STYLE);
    ui->cameraLabel->setStyleSheet(CAM_LABEL_STYLE);

    for (QPushButton* button : buttonList()) {
				if (button) {
						button->setStyleSheet(BTN_STYLE);
				}
				else {
						LOG_WARN("Nullptr button in buttonList()");
				}
    }
}

void MainWindow::connectSignals()
{
		auto connectWithCheck = [this](QPushButton* btn, auto slot, const QString& name) {
				bool rc = connect(btn, &QPushButton::clicked, this, slot);
				if (!rc) {
						LOG_WARN(QString("%1 connection failed!").arg(name));
						showErrorMessage("Connection Error", QString("Failed to connect %1 button.").arg(name));
				}
		};

		connectWithCheck(ui->registerButton, &MainWindow::onRegisterFace, "Register Button");
		connectWithCheck(ui->clearButton, &MainWindow::onClearUsers, "Clear Button");
		connectWithCheck(ui->btnShowUsers, &MainWindow::showUserList, "Show User Button");
		connectWithCheck(ui->showUserImages, &MainWindow::onShowUserImages, "Show User Image Button");
		connectWithCheck(ui->ExitButton, &MainWindow::onExitProgram, "Exit Button");
}

QList<QPushButton*> MainWindow::buttonList() const
{
		return {
			ui->registerButton,
			ui->clearButton,
			ui->btnShowUsers,
			ui->showUserImages,
			ui->ExitButton
		};
}

void MainWindow::showErrorMessage(const QString& title, const QString& message)
{
		QMessageBox::critical(this, title, message);
}

void MainWindow::setupFdUltrasonic()
{
		QThread *FD_ultrasonicThread = new QThread(this);

    // ì“°ë ˆë“œ ê°ì²´ ìƒì„±
		FD_UltrasonicWorker *FD_ultrasonicWorker = new FD_UltrasonicWorker();

		// ì›Œì»¤ë¥¼ ì“°ë ˆë“œë¡œ ì´ë™
		FD_ultrasonicWorker->moveToThread(FD_ultrasonicThread);

		// ì‹œì‘ë˜ë©´ process() ì‹¤í–‰
		connect(FD_ultrasonicThread, &QThread::started, FD_ultrasonicWorker, &FD_UltrasonicWorker::FD_process);

		// ì‹ í˜¸ ì—°ê²°
		connect(FD_ultrasonicWorker, &FD_UltrasonicWorker::personDetected, this, [this]() {
				isFaceDetecting = true;
				ui->statusbar->showMessage("ì‚¬ëŒ ê°ì§€ë¨. ì–¼êµ´ ì¸ì‹ ì¤‘...");
		});

		connect(FD_ultrasonicWorker, &FD_UltrasonicWorker::personLeft, this, [this]() {
				isFaceDetecting = false;
				ui->statusbar->showMessage("ì‚¬ëŒ ì—†ìŒ. ëŒ€ê¸° ì¤‘...");
		});

		// ì“°ë ˆë“œ ì‹œì‘
		Logger::writef("[%s] FD_Ultrasonic Thread start!!\n", __func__);
		FD_ultrasonicThread->start();
}

void MainWindow::setupDdUltrasonic()
{
		QThread *DD_ultrasonicThread = new QThread(this);

		DD_UltrasonicWorker *DD_ultrasonicWorker = new DD_UltrasonicWorker();

		DD_ultrasonicWorker->moveToThread(DD_ultrasonicThread);

		connect(DD_ultrasonicThread, &QThread::started, DD_ultrasonicWorker, &DD_UltrasonicWorker::DD_process);

		connect(DD_ultrasonicWorker, &DD_UltrasonicWorker::doorDetected, this, [this]() {
				isDoorDetecting = true;
				//ui->statusbar2->showMessage("ë¬¸ì´ ë‹«í˜”ìˆìŠµë‹ˆë‹¤..");
		});

		connect(DD_ultrasonicWorker, &DD_UltrasonicWorker::doorLeft, this, [this]() {
				isDoorDetecting = false;
				//ui->statusbar2->showMessage("ë¬¸ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤..");
		});

		Logger::writef("[%s] DD_Ultrasonic Thread start!!\n", __func__);
		DD_ultrasonicThread->start();
}

void MainWindow::setupQTimer()
{
		timer = new QTimer(this);
		// íƒ€ì´ë¨¸ëŠ” ì–¼êµ´ ê°ì§€ ì¤‘ì¼ ë•Œë§Œ ì‹¤í–‰
		connect(timer, &QTimer::timeout, this, [this]() {
				if (isDoorDetecting) {
						if (isFaceDetecting) {
								overlayLabel->hide();

								updateFrame();
						}
						else {
								showComeImage();
						}
				}
				else {
						showOpenImage();
				}
							
		});
		timer->start(100);
}

void MainWindow::showComeImage()
{
		QPixmap pixmap(COME_IMAGE_PATH);
	
		if (pixmap.isNull()) {
				qDebug() << "Failed to load come image";
				Logger::writef("[%s] Failed to load the come image!!", __func__);
		}

		pixmap = pixmap.scaled(overlayLabel->size(),  Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);

		overlayLabel->setPixmap(pixmap);
		overlayLabel->resize(ui->cameraLabel->size());
		overlayLabel->show();
}

void MainWindow::showOpenImage()
{
		QPixmap pixmap(OPEN_IMAGE_PATH);
		if (pixmap.isNull()) {
				qDebug() << "Failed to load open image";
				Logger::writef("[%s] Failed to load the open image!!", __func__);
		}

		pixmap = pixmap.scaled(overlayLabel->size(), Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation);

		overlayLabel->setPixmap(pixmap);
		overlayLabel->resize(ui->cameraLabel->size());
		overlayLabel->show();
}

/*
void MainWindow::createLBPH()
{
		Logger::writef("[%s] LBPHFaceRecognizer loading...", __func__);

		try {
				faceRecognizer = face::LBPHFaceRecognizer::create();
		} catch (Exception& e) {
				qDebug() << "LBPHFaceRecognizer ìƒì„± ì‹¤íŒ¨:" << e.what();
				Logger::writef("[%s] LBPHFaceRecognizer loading failed...", __func__);
		}
}

void MainWindow::loadFaceCascade()
{
		Logger::writef("[%s] face cascade loading...", __func__);

		// ì–¼êµ´ ì¸ì‹ìš© ë¶„ë¥˜ê¸° ë¡œë“œ
    if (!faceCascade.load(HAARCASCADE_FRONTALFACE)) {
				QMessageBox::critical(this, "Error", "ì–¼êµ´ ë¶„ë¥˜ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				Logger::writef("[%s] ì–¼êµ´ ë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				exit(1);
		}
}

void MainWindow::loadEyesCascade()
{
		Logger::writef("[%s] Eys cascade loading...", __func__);

		// ëˆˆ ì¸ì‹ìš© ë¶„ë¥˜ê¸° ë¡œë“œ
		if (!eyeCascade.load(HAARCASCADE_EYE)) {
				QMessageBox::critical(this, "Error", "ëˆˆ ë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				Logger::writef("[%s] ëˆˆë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤...", __func__);
				exit(1);
		}
}

void MainWindow::registerExistingUser()
{
		vector<Mat> images;
		vector<int> labels;

		UserData newUser;

		if (!fs::exists(USER_FACES_DIR)) {
				fs::create_directory(USER_FACES_DIR);
				Logger::writef("[%s] Create file(%s)", __func__, USER_FACES_DIR);
		}


		int rc = fs::is_directory(USER_FACES_DIR);
		
		if (rc == 1) {
				// ê¸°ì¡´ ë“±ë¡ ì‚¬ìš©ì ì–¼êµ´ ë°ì´í„° ë¡œë“œ
				for (const auto& entry : fs::directory_iterator(USER_FACES_DIR)) {
						string fname = entry.path().filename().string();
						// filename pattern: face_<label>_&.png
						if (!fname.empty()) {

								size_t firstUnderscore = fname.find('_');
								size_t secondUnderscore = fname.find('_', firstUnderscore + 1);
								size_t thirdUnderscore = fname.find('_', secondUnderscore + 1);

								int label = std::stoi(fname.substr(firstUnderscore + 1, secondUnderscore - firstUnderscore - 1));
								string name = fname.substr(secondUnderscore + 1, thirdUnderscore - secondUnderscore - 1);

								//cvtColor(frame, frame, cv::COLOR_BGR2RGB);
								//int label = std::stoi(fname.substr(fname.find('_') + 1, fname.find('_', fname.find('_') + 1) - fname.find('_') - 1));
								//string name = fname.substr(fname.find('_') + 1, 

								Mat grayImg = cv::imread(entry.path().string(), IMREAD_GRAYSCALE);
								cv::resize(grayImg, grayImg, Size(200, 200));

								Mat colorImg = cv::imread(entry.path().string(), IMREAD_COLOR);
								cv::resize(colorImg, colorImg, Size(200, 200));
								cv::cvtColor(colorImg, colorImg, cv::COLOR_BGR2RGB);


								storedFaces[label].push_back(grayImg);
								//cout << "label: " << label << endl;
								images.push_back(grayImg);
								labels.push_back(label);
		
								newUser.label			= label;
								newUser.name			= QString::fromStdString(name);
								newUser.colorFaceImage = colorImg;
								newUser.grayFaceImage  = grayImg; 
								storedUsers.push_back(newUser);
						}
				}
				printf ("[%s] labels count: %d\n", __func__, labels.size());
		}
		else {
				Logger::writef("[%s] Is not exists existing faces!!", __func__);
				QMessageBox::information(this, "Error", "ê¸°ì¡´ ë“±ë¡ëœ ì–¼êµ´ì´ ì—†ìŠµë‹ˆë‹¤.\n ì–¼êµ´ì„ ìƒˆë¡œ ë“±ë¡í•´ì£¼ì„¸ìš”!\n");
		}

		Logger::writef("[%s] Load the existing face into program from %s!!", __func__, USER_FACES_DIR);

		//if (!images.empty()) faceRecognizer->train(images, labels);
		//else Logger::writef("[%s] Failed to existing faces train!!", __func__);

		faceRecognizer->train(images, labels);
		loadLabelMap();

}

bool MainWindow::isUserNameExists(const QString& name) 
{
		for (const auto& [label, storedName] : labelMap) {
				if (QString::fromStdString(storedName) == name) return true;
		}

		return false;
}
*/

void MainWindow::onClearUsers() {
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "ëª¨ë“  ì‚¬ìš©ì ì‚­ì œ", "ëª¨ë“  ë“±ë¡ëœ ì‚¬ìš©ì ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                  QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::Yes) {
        clearAllUserData();
        ui->statusbar->showMessage("ëª¨ë“  ì‚¬ìš©ì ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
}


void MainWindow::clearAllUserData()
{
		// Delete face images
		for (const auto& entry : fs::directory_iterator(USER_FACES_DIR)) {
				if(entry.path().filename().string().find("face_") == 0) {
						fs::remove(entry.path());
				}
		}

		// Delete label map
		if (access(USER_LABEL_FILE, F_OK) == 0) {
				cout << "[" << __func__ << "] Clear user data file!!!" << endl;
				fs::remove(USER_LABEL_FILE);
				ifstream file(USER_LABEL_FILE);
				file.close();
		}

		// Delete memory
		storedUsers.clear();
		labelMap.clear();

		cout << "User data is initialized!!!" << endl;
}

MainWindow::~MainWindow() {
    cap.release();  // ì¹´ë©”ë¼ ì¢…ë£Œ

		if (workerThread && workerThread->isRunning()) {
				worker->stop();
				workerThread->quit();
				workerThread->wait();
		}

		delete worker;
		delete workerThread;

    delete ui;
}

/*
int MainWindow::getNextLabel() {
		// label.txtì—ì„œ ë§ˆì§€ë§‰ ë¼ë²¨ ì½ê¸°
		ifstream ifs(USER_LABEL_FILE);
		
		// if not exist label.txt, Label.txt be create to /usr/local/etc/face_doorlock
		if (!access(USER_LABEL_FILE, F_OK) == 0) {
				ifstream file(USER_LABEL_FILE);
				file.close();
		}
	

		int maxLabel = 0;

		if (ifs.is_open()) {
				int lbl;
				string name;
				while (ifs >> lbl >> name) {
						//cout << "name: " << name << ",  label: " << lbl << endl;
						if (lbl > maxLabel) maxLabel = lbl;
				}

		}

		return maxLabel + 1;
}

void MainWindow::loadLabelMap() 
{
		int rc = 0;

		ifstream ifs(USER_LABEL_FILE);

		rc = Utile::checkFileExist(USER_LABEL_FILE, R_OK + W_OK);
		if (rc == -1) {
				rc = Utile::createFile(USER_LABEL_FILE, R_OK + W_OK);
				if (rc == -1) {
						Logger::writef("[%s] Failed to create file(%s)\n", __func__, USER_LABEL_FILE);		
						exit(1);
				}
		}

		if (ifs.is_open()) {
				int lbl;
				string name;

				while (ifs >> lbl >> name) {
						labelMap[lbl] = name;
				}
		}
}

void MainWindow::saveLabelToFile(int label, const string &name) {
		//if (access(USER_LABEL_FILE, F_OK) == 0) {
				ofstream ofs (USER_LABEL_FILE, ios::app);
				if (ofs.is_open()) ofs << label << " " << name << endl;
		//}
}
	

void MainWindow::onRegisterFace() 
{
		if (isRegistering) return;

		userName = QInputDialog::getText(this, "ì‚¬ìš©ì ë“±ë¡", "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:");
		if (userName.isEmpty()) return;

		if (isUserNameExists(userName)) {
				QMessageBox::warning(this, "ì¤‘ë³µ ì‚¬ìš©ì", "ì´ë¯¸ ë“±ë¡ëœ ì‚¬ìš©ì ì´ë¦„ì…ë‹ˆë‹¤.");
				return;
		}

		currentLabel = getNextLabel();
		captureCount = 0;
		isRegistering = true;
		ui->statusbar->showMessage("[ë“±ë¡ ì¤‘]" + userName + ": 0/20");
}

void MainWindow::showUserList() 
{
		QString filePath = QString::fromStdString(USER_LABEL_FILE);
		QFile file(filePath);

		if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
				QMessageBox::warning(this, "ì˜¤ë¥˜",  "label.txt íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
				return;
		}

		QStringList users;
		while (!file.atEnd()) {
				QByteArray line = file.readLine();
				QString str(line);
				QStringList parts = str.trimmed().split(' ');
				if (parts.size() >= 2) {
						users.append(parts[0] + ": " + parts[1]);
				}
		}

		if (users.isEmpty()) {
				QMessageBox::information(this, "ì‚¬ìš©ì ëª©ë¡", "ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.");
		} else {
				 QMessageBox::information(this, "ì‚¬ìš©ì ëª©ë¡", users.join("\n"));
		}
}
*/

void MainWindow::onExitProgram()
{
		QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "í”„ë¡œê·¸ë¨ ì¢…ë£Œ", "í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                  QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::Yes) {
				exit(1);
    }
}

void MainWindow::onShowUserImages()
{
    // Create new QDialog
    QDialog *dialog = new QDialog(this);
    dialog->setWindowTitle("ë“±ë¡ëœ ì‚¬ìš©ì ì´ë¯¸ì§€ ëª©ë¡");

    // Show the image as a QListWidget
    QListWidget *listWidget = new QListWidget(dialog);

    // ğŸ”´ QMapìœ¼ë¡œ ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ì¸ë„¤ì¼ê³¼ ì—°ë™)
    QMap<QListWidgetItem*, cv::Mat> originalImages;

    // ğŸ‘‰ storedUsers ìˆœíšŒ (ì´ì œ UserDataì˜ colorFaceImageë¥¼ ì“¸ê±°ì•¼!)
    for (const auto& user : storedUsers) {
        cv::Mat colorFace = user.colorFaceImage;

        // ğŸ”´  OpenCV Matë¥¼ QImageë¡œ ë³€í™˜
        QImage img(colorFace.data,
                    colorFace.cols,
                    colorFace.rows,
                    static_cast<int>(colorFace.step),
                    QImage::Format_RGB888);

        // ğŸ”´  QPixmapìœ¼ë¡œ ë³€í™˜í•´ì„œ QListWidgetì— ì¶”ê°€
        QPixmap pixmap = QPixmap::fromImage(img).scaled(64, 64, Qt::KeepAspectRatio);
        QListWidgetItem *item = new QListWidgetItem;
        item->setIcon(QIcon(pixmap));
        item->setText(QString("Label: %1, Name: %2").arg(user.label).arg(user.name));
        listWidget->addItem(item);

        // ğŸ‘‰ ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ë³µì‚¬!)
        originalImages[item] = colorFace.clone();
    }

    // ğŸ”´ 2ï¸âƒ£ ì•„ì´í…œ í´ë¦­ ì‹œ í° ì´ë¯¸ì§€ë¡œ ë³´ê¸°
    connect(listWidget, &QListWidget::itemClicked, [=](QListWidgetItem *item){
        // ì›ë³¸ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
        cv::Mat colorFace = originalImages[item];

        // QImage ë³€í™˜
        QImage img(colorFace.data,
                    colorFace.cols,
                    colorFace.rows,
                    static_cast<int>(colorFace.step),
                    QImage::Format_RGB888);

        // ğŸ‘‰ QDialogë¡œ í° ì´ë¯¸ì§€ ë³´ê¸°
        QDialog *imageDialog = new QDialog(dialog);
        imageDialog->setWindowTitle(item->text());

        QLabel *imageLabel = new QLabel(imageDialog);
        imageLabel->setPixmap(QPixmap::fromImage(img).scaled(500, 500, Qt::KeepAspectRatio));

        QVBoxLayout *imageLayout = new QVBoxLayout(imageDialog);
        imageLayout->addWidget(imageLabel);
        imageDialog->setLayout(imageLayout);

        imageDialog->exec();
        delete imageDialog;
    });

    QVBoxLayout *layout = new QVBoxLayout(dialog);
    layout->addWidget(listWidget);
    dialog->setLayout(layout);

    dialog->exec();
    delete dialog;
}

/*
// ì‚¬ìš©ë˜ê³  ìˆì§€ ì•ŠìŒ ë¦¬êµ¬í˜„ì˜ˆì •
bool MainWindow::isDuplicateFace(const Mat& newFace)
{
		if (!faceRecognizer || newFace.empty()) {
        std::cerr << "[ì˜¤ë¥˜] ì–¼êµ´ ì¸ì‹ê¸°ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì…ë ¥ ì´ë¯¸ì§€ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤." << std::endl;
        return false;
    }

    int predictedLabel = -1;
    double confidence = 0.0;

    // ì˜ˆì¸¡ ìˆ˜í–‰ (ì…ë ¥ì€ ë°˜ë“œì‹œ í‘ë°±ì´ì–´ì•¼ í•¨)
    cv::Mat gray;
    if (newFace.channels() == 3)
        cv::cvtColor(newFace, gray, cv::COLOR_RGB2GRAY);
    else
        gray = newFace;

		//if (!storedFaces.empty()) {
		if (!storedUsers.empty()) {
				faceRecognizer->predict(gray, predictedLabel, confidence);
		}

    std::cout << "ì˜ˆì¸¡ëœ ë¼ë²¨: " << predictedLabel << ", ì‹ ë¢°ë„: " << confidence << std::endl;

    // ì‹ ë¢°ë„ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µ ì—¬ë¶€ íŒë‹¨
    const double DUPLICATE_THRESHOLD = 50.0; // ì‘ì„ìˆ˜ë¡ ì—„ê²© (OpenCV LBPH ê¸°ì¤€ 50~100 ì ì ˆ)

    return (confidence < DUPLICATE_THRESHOLD) && (confidence) && (predictedLabel != -1);
}

Mat MainWindow::alignAndNormalizeFace(const Mat& grayFrame, const Rect& faceRect)
{
		Mat faceROI = grayFrame(faceRect).clone();

		// ëˆˆ ê²€ì¶œ
		vector<Rect> eyes;
		eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 10, 0, Size(20, 20));

		if (eyes.size() < 2) return {};	 // ëˆˆì´ 2ê°œ ë¯¸ë§Œì´ë©´ ì‹¤íŒ¨

		// ëˆˆ 2ê°œë¥¼ ì¢Œ/ìš°ë¡œ ì •ë ¬
		Point eye1 = (eyes[0].x < eyes[1].x) ? eyes[0].tl() : eyes[1].tl();
		Point eye2 = (eyes[0].x < eyes[1].x) ? eyes[1].tl() : eyes[0].tl();

		// ëˆˆ ì¤‘ì‹¬ ê³„ì‚°
		eye1 += Point(eyes[0].width/2, eyes[0].height/2);
		eye2 += Point(eyes[1].width/2, eyes[1].height/2);

		// ê°ë„ ê³„ì‚°
		double dy = eye2.y - eye1.y;
		double dx = eye2.x - eye1.x;
		double angle = atan2(dy, dx) * 180.0 / CV_PI;

		// ì–¼êµ´ ì¤‘ì•™ ê¸°ì¤€ íšŒì „
		Point2f center(faceROI.cols/2.0F, faceROI.rows/2.0F);
		Mat rot = getRotationMatrix2D(center, angle, 1.0);

		Mat aligned;
		warpAffine(faceROI, aligned, rot, faceROI.size());

		// ë°ê¸° ë³´ì • + í¬ê¸° ì¡°ì •
		equalizeHist(aligned, aligned);
		cv::resize(aligned, aligned, Size(200, 200));

		//cout << "[" << __func__ << "] Face is aligned and normalized!!" << endl;
		return aligned;
}

void MainWindow::updateFrame() {
    Mat frame, gray;
		Mat colorFace;

    cap >> frame;
    if (frame.empty()) return;

		// ì–¼êµ´ ì¸ì‹ìš© í‘ë°± ì´ë¯¸ì§€ ìƒì„±
    cvtColor(frame, gray, cv::COLOR_RGB2GRAY);
		equalizeHist(gray, gray);

		// ì–¼êµ´ íƒì§€
		vector<Rect> faces;
		faceCascade.detectMultiScale(
				gray, faces,
				1.1,					// scaleFactor: ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©° íƒì§€ (1.1~1.3 ì¶”ì²œ)					
				5,						// minNeighbors: ìµœì†Œ ì´ì›ƒ ìˆ˜ (ê°’ì´ ë†’ì„ìˆ˜ë¡ ì •ë°€, 3~6 ì¶”ì²œ)
				CASCADE_SCALE_IMAGE,
				Size(100, 100) // ìµœì†Œ ì–¼êµ´ í¬ê¸° ì„¤ì • (ë„ˆë¬´ ì‘ìœ¼ë©´ false positive ë°œìƒ)			
		);

		for (const auto& face : faces) {

				colorFace = frame(face);

				Mat alignedFace = alignAndNormalizeFace(gray, face);
				if (alignedFace.empty()) continue;

				//Mat faceROI = gray(face);
				//cv::resize(faceROI, faceROI, Size(200, 200));


				// ì–¼êµ´ ì˜ì—­ì—ì„œ ëˆˆ ê²€ì¶œ
				vector<Rect> eyes;
				eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 10, 0, cv::Size(20, 20));
				if (eyes.size() < 2) continue; // ëˆˆì´ 2ê°œ ë¯¸ë§Œì´ë©´ false positive ì œê±°
				// ëˆˆë„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ê³  ì‹¶ìœ¼ë©´ ì¶”ê°€
				for (const auto& eye : eyes) {
						cv::Point eyeCenter(face.x + eye.x + eye.width / 2, face.y + eye.y + eye.height / 2);
						int radius = cvRound((eye.width + eye.height) * 0.25);
						cv::circle(frame, eyeCenter, radius, cv::Scalar(255, 0, 0), 2);
				}

				QString labelText;
				Scalar boxColor;


				if (!isRegistering) {
						// ë“±ë¡ ëª¨ë“œê°€ ì•„ë‹ ë•Œ ë“±ë¡ëœ ì‚¬ìš©ìì™€ ë¹„êµ
						int predictedLabel = -1;
						double confidence = 999.0;

						if (!storedFaces.empty()) {
								faceRecognizer->predict(alignedFace, predictedLabel, confidence);
						}

						//cout << "[" << __func__ << "] predictedLabel: " << predictedLabel << "confidence: " << confidence << endl; 
						if (confidence < 60.0 && labelMap.count(predictedLabel)) {
								labelText = QString::fromStdString(labelMap[predictedLabel]);
								boxColor = Scalar(0, 255, 0);
						}
						else {
								labelText = "Unknown";
								boxColor= Scalar(0, 0, 255);
						}
						rectangle(frame, face, boxColor, 2);

						putText(frame, labelText.toStdString(), Point(face.x + 100, face.y + face.height + 20),
										FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);
				}
				else if (isRegistering) {
						labelText = "Registering...";
						boxColor = Scalar(255, 0, 0);

						rectangle(frame, face, Scalar(255, 0, 0), 2);
						putText(frame, labelText.toStdString(), Point(face.x, face.y + face.height + 20),
										FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);

						//rectangle(frame, cv::Rect(0, 0, frame.cols - 1, frame.rows - 1), Scalar(0, 255, 0), 4);

						if (captureCount == 0 && isDuplicateFace(alignedFace)) {
								ui->statusbar->showMessage("ì´ë¯¸ ë“±ë¡ëœ ì–¼êµ´ì…ë‹ˆë‹¤.");
								isRegistering = false;
								return;
						}

						if (captureCount < 20) {
								if (!fs::exists(USER_FACES_DIR)) 
										fs::create_directory(USER_FACES_DIR);

								UserData newUser;

								string filename = CONF_PATH + string("data/face_") + to_string(currentLabel) + "_" + userName.toStdString() + "_" + to_string(captureCount + 1) + ".png";
								newUser.label = currentLabel;
								newUser.colorFaceImage = colorFace;
								newUser.grayFaceImage = alignedFace;

								storedUsers.push_back(newUser);
								//cout << "[1'th label]" << storedUsers[0].label << endl;

								//if (!imwrite(filename, alignedFace)) {
								if (!imwrite(filename, colorFace)) {
									qDebug() << "ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨: " << QString::fromStdString(filename);
								}
								storedFaces[currentLabel].push_back(alignedFace);
								labelMap[currentLabel] = userName.toStdString();
								captureCount++;
								ui->statusbar->showMessage(QString("[ë“±ë¡ì¤‘] %1: %2/20").arg(userName).arg(captureCount));
								if (captureCount >= 20) {
										saveLabelToFile(currentLabel, userName.toStdString());

										vector<Mat> images;
										vector<int> labels;
										for (const auto& entry : storedFaces) {
												for (const auto& img : entry.second) {
														images.push_back(img);
														labels.push_back(entry.first);
												}
										}

										faceRecognizer->train(images, labels);
										isRegistering = false;
										ui->statusbar->showMessage("[ë“±ë¡ ì™„ë£Œ]" + userName);
								}
						}

										}

				//cv::cvtColor(frame, frame, cv::COLOR_BGR2RGB);
				//QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_RGB888);
				//ui->cameraLabel->setPixmap(QPixmap::fromImage(qimg));
		}

		cvtColor(frame, frame, COLOR_BGR2RGB);
    //QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_BGR888);
    QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_RGB888);
    ui->cameraLabel->setPixmap(QPixmap::fromImage(qimg));
}
void MainWindow::updateFrame() {
    Mat frame, gray;
    Mat colorFace;

    cap >> frame;
    if (frame.empty()) return;

    cvtColor(frame, gray, cv::COLOR_RGB2GRAY);
    equalizeHist(gray, gray);

    vector<Rect> faces;
    faceCascade.detectMultiScale(
        gray, faces, 1.1, 5, CASCADE_SCALE_IMAGE, Size(100, 100));

    for (const auto& face : faces) {
        colorFace = frame(face);

        Mat alignedFace = alignAndNormalizeFace(gray, face);
        if (alignedFace.empty()) continue;

        QString labelText;
        Scalar boxColor;

        if (!isRegistering) {
            int predictedLabel = -1;
            double confidence = 999.0;

            //if (!storedFaces.empty()) {
            if (!storedUsers.empty()) {
                faceRecognizer->predict(alignedFace, predictedLabel, confidence);
            }

            if (confidence < 60.0 && labelMap.count(predictedLabel)) {
                labelText = QString::fromStdString(labelMap[predictedLabel]);
                boxColor = Scalar(0, 255, 0);
            } else {
                labelText = "Unknown";
                boxColor= Scalar(0, 0, 255);
            }

            rectangle(frame, face, boxColor, 2);
            putText(frame, labelText.toStdString(), Point(face.x + 100, face.y + face.height + 20),
                    FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);
        }
        else if (isRegistering) {
            labelText = "Registering...";
            boxColor = Scalar(255, 0, 0);

            rectangle(frame, face, Scalar(255, 0, 0), 2);
            putText(frame, labelText.toStdString(), Point(face.x, face.y + face.height + 20),
                    FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);

            if (captureCount == 0 && isDuplicateFace(alignedFace)) {
                ui->statusbar->showMessage("ì´ë¯¸ ë“±ë¡ëœ ì–¼êµ´ì…ë‹ˆë‹¤.");
                isRegistering = false;
                return;
            }

            if (captureCount < 20) {
                if (!fs::exists(USER_FACES_DIR))
                    fs::create_directory(USER_FACES_DIR);

                UserData newUser;

                string filename = CONF_PATH + string("data/face_") + to_string(currentLabel) + "_" + userName.toStdString() + "_" + to_string(captureCount + 1) + ".png";
                newUser.label = currentLabel;
								newUser.name  = userName;
                newUser.colorFaceImage = colorFace;
                newUser.grayFaceImage = alignedFace;

                storedUsers.push_back(newUser);

                if (!imwrite(filename, colorFace)) {
                  qDebug() << "ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨: " << QString::fromStdString(filename);
                }
                storedFaces[currentLabel].push_back(alignedFace);
                labelMap[currentLabel] = userName.toStdString();
                captureCount++;
                ui->statusbar->showMessage(QString("[ë“±ë¡ì¤‘] %1: %2/20").arg(userName).arg(captureCount));

                if (captureCount >= 20) {
                    saveLabelToFile(currentLabel, userName.toStdString());
                    vector<Mat> images;
                    vector<int> labels;
                    for (const auto& entry : storedFaces) {
                        for (const auto& img : entry.second) {
                            images.push_back(img);
                            labels.push_back(entry.first);
                        }
                    }
                    faceRecognizer->train(images, labels);
                    isRegistering = false;
                    ui->statusbar->showMessage("[ë“±ë¡ ì™„ë£Œ]" + userName);
                }
            }
        }
    }

    // ğŸ”´ ë£¨í”„ê°€ ëë‚œ ë’¤ ìµœì¢… í”„ë ˆì„ì„ í•œ ë²ˆë§Œ ê·¸ë¦¬ê¸°!
    cvtColor(frame, frame, cv::COLOR_BGR2RGB);
    QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_RGB888);
    ui->cameraLabel->setPixmap(QPixmap::fromImage(qimg));
}
*/

