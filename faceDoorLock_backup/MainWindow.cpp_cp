// -------------------- gui/MainWindow.cpp --------------------
#include "MainWindow.hpp"


// ì €ì¥ëœ ì–¼êµ´ ë§¤í•‘: label -> gray face image
map<int, vector<Mat>> storedFaces;

std::vector<UserData> storedUsers;

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)
{
		setupUi();
		setupQTimer();

		openCamera();

		createLBPH();
		loadFaceCascade();
		loadEyesCascade();

		registerExistingUser();

		setupFdUltrasonic();
		setupDdUltrasonic();

}

void MainWindow::openCamera()
{
    cap.open(CAM_NUM);
    if (!cap.isOpened()) {
        QMessageBox::critical(this, "Error", "ì¹´ë©”ë¼ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
				Logger::writef("[%s] Camera open was failed(cam %d)!!\n", __func__, CAM_NUM);
        exit(1);
    }

		Logger::writef("[%s] Camera open was successfully(cam %d)!!\n", __func__, CAM_NUM);
		return;
}

void MainWindow::setupUi()
{
		ui = new Ui::MainWindow;

		ui->setupUi(this);

		// QLabelì´ í¬ê¸°ì— ë§ì¶° ìë™ ë¦¬ì‚¬ì´ì§• ë˜ë„ë¡ ì„¤ì •
    ui->cameraLabel->setScaledContents(true);

    // ì°½ì„ ëª¨ë‹ˆí„° í¬ê¸°ì— ë§ê²Œ ìµœì†Œë¡œ í‘œì‹œ
    this->setMinimumSize(640, 480);
		
		ui->statusbar->setStyleSheet(STATUS_BAR_STYLE);
		ui->cameraLabel->setStyleSheet(CAM_LABEL_STYLE);

		ui->registerButton->setStyleSheet(BTN_STYLE);
		ui->clearButton->setStyleSheet(BTN_STYLE);
		ui->btnShowUsers->setStyleSheet(BTN_STYLE);
		ui->showUserImages->setStyleSheet(BTN_STYLE);

		ui->ExitButton->setStyleSheet(BTN_STYLE);


    connect(ui->registerButton, &QPushButton::clicked, this, &MainWindow::onRegisterFace);

		connect(ui->clearButton, &QPushButton::clicked, this, &MainWindow::onClearUsers);

		connect(ui->btnShowUsers, &QPushButton::clicked, this, &MainWindow::showUserList);

		connect(ui->showUserImages, &QPushButton::clicked, this, &MainWindow::onShowUserImages);

		connect(ui->ExitButton, &QPushButton::clicked, this, &MainWindow::onExitProgram);

		return;
}


void MainWindow::setupFdUltrasonic()
{
		QThread *FD_ultrasonicThread = new QThread(this);

    // ì“°ë ˆë“œ ê°ì²´ ìƒì„±
		FD_UltrasonicWorker *FD_ultrasonicWorker = new FD_UltrasonicWorker();

		// ì›Œì»¤ë¥¼ ì“°ë ˆë“œë¡œ ì´ë™
		FD_ultrasonicWorker->moveToThread(FD_ultrasonicThread);

		// ì‹œì‘ë˜ë©´ process() ì‹¤í–‰
		connect(FD_ultrasonicThread, &QThread::started, FD_ultrasonicWorker, &FD_UltrasonicWorker::FD_process);

		// ì‹ í˜¸ ì—°ê²°
		connect(FD_ultrasonicWorker, &FD_UltrasonicWorker::personDetected, this, [this]() {
				isFaceDetecting = true;
				ui->statusbar->showMessage("ì‚¬ëŒ ê°ì§€ë¨. ì–¼êµ´ ì¸ì‹ ì¤‘...");
		});

		connect(FD_ultrasonicWorker, &FD_UltrasonicWorker::personLeft, this, [this]() {
				isFaceDetecting = false;
				ui->statusbar->showMessage("ì‚¬ëŒ ì—†ìŒ. ëŒ€ê¸° ì¤‘...");
		});

		// ì“°ë ˆë“œ ì‹œì‘
		Logger::writef("[%s] FD_Ultrasonic Thread start!!\n", __func__);
		FD_ultrasonicThread->start();
}

void MainWindow::setupDdUltrasonic()
{
		QThread *DD_ultrasonicThread = new QThread(this);

		DD_UltrasonicWorker *DD_ultrasonicWorker = new DD_UltrasonicWorker();

		DD_ultrasonicWorker->moveToThread(DD_ultrasonicThread);

		connect(DD_ultrasonicThread, &QThread::started, DD_ultrasonicWorker, &DD_UltrasonicWorker::DD_process);

		connect(DD_ultrasonicWorker, &DD_UltrasonicWorker::doorDetected, this, [this]() {
				isDoorDetecting = true;
				//ui->statusbar2->showMessage("ë¬¸ì´ ë‹«í˜”ìˆìŠµë‹ˆë‹¤..");
		});

		connect(DD_ultrasonicWorker, &DD_UltrasonicWorker::doorLeft, this, [this]() {
				isDoorDetecting = false;
				//ui->statusbar2->showMessage("ë¬¸ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤..");
		});

		Logger::writef("[%s] DD_Ultrasonic Thread start!!\n", __func__);
		DD_ultrasonicThread->start();
}

void MainWindow::setupQTimer()
{
		timer = new QTimer(this);

		// íƒ€ì´ë¨¸ëŠ” ì–¼êµ´ ê°ì§€ ì¤‘ì¼ ë•Œë§Œ ì‹¤í–‰
		connect(timer, &QTimer::timeout, this, [this]() {
				if (isDoorDetecting) {
						if (isFaceDetecting)
								updateFrame();
				}
		});
		timer->start(100);
}

void MainWindow::createLBPH()
{
		Logger::writef("[%s] LBPHFaceRecognizer loading...", __func__);

		try {
				faceRecognizer = face::LBPHFaceRecognizer::create();
		} catch (Exception& e) {
				qDebug() << "LBPHFaceRecognizer ìƒì„± ì‹¤íŒ¨:" << e.what();
				Logger::writef("[%s] LBPHFaceRecognizer loading failed...", __func__);
		}
}

void MainWindow::loadFaceCascade()
{
		Logger::writef("[%s] face cascade loading...", __func__);

		// ì–¼êµ´ ì¸ì‹ìš© ë¶„ë¥˜ê¸° ë¡œë“œ
    if (!faceCascade.load(HAARCASCADE_FRONTALFACE)) {
				QMessageBox::critical(this, "Error", "ì–¼êµ´ ë¶„ë¥˜ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				Logger::writef("[%s] ì–¼êµ´ ë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				exit(1);
		}
}

void MainWindow::loadEyesCascade()
{
		Logger::writef("[%s] Eys cascade loading...", __func__);

		// ëˆˆ ì¸ì‹ìš© ë¶„ë¥˜ê¸° ë¡œë“œ
		if (!eyeCascade.load(HAARCASCADE_EYE)) {
				QMessageBox::critical(this, "Error", "ëˆˆ ë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
				Logger::writef("[%s] ëˆˆë¶„ë¥˜ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤...", __func__);
				exit(1);
		}
}

void MainWindow::registerExistingUser()
{
		vector<Mat> images;
		vector<int> labels;

		if (!fs::exists(USER_FACES_DIR)) {
				fs::create_directory(USER_FACES_DIR);
				Logger::writef("[%s] Create file(%s)", __func__, USER_FACES_DIR);
		}


		int rc = fs::is_directory(USER_FACES_DIR);
		
		if (rc == 1) {
				// ê¸°ì¡´ ë“±ë¡ ì‚¬ìš©ì ì–¼êµ´ ë°ì´í„° ë¡œë“œ
				for (const auto& entry : fs::directory_iterator(USER_FACES_DIR)) {
						string fname = entry.path().filename().string();
						// filename pattern: face_<label>_&.png
						if (!fname.empty()) {
								int label = stoi(fname.substr(5, fname.find('_', 5)-5));

								Mat img = cv::imread(entry.path().string(), IMREAD_GRAYSCALE);
								cv::resize(img, img, Size(200, 200));

								storedFaces[label].push_back(img);
								//cout << "label: " << label << endl;
								images.push_back(img);
								labels.push_back(label);
						}
				}
				printf ("[%s] labels count: %d\n", __func__, labels.size());
		}
		else {
				Logger::writef("[%s] Is not exists existing faces!!", __func__);
				QMessageBox::information(this, "Error", "ê¸°ì¡´ ë“±ë¡ëœ ì–¼êµ´ì´ ì—†ìŠµë‹ˆë‹¤.\n ì–¼êµ´ì„ ìƒˆë¡œ ë“±ë¡í•´ì£¼ì„¸ìš”!\n");
		}

		Logger::writef("[%s] Load the existing face into program from %s!!", __func__, USER_FACES_DIR);

		if (!images.empty()) faceRecognizer->train(images, labels);
		else Logger::writef("[%s] Failed to existing faces train!!", __func__);

		loadLabelMap();

}

bool MainWindow::isUserNameExists(const QString& name) 
{
		for (const auto& [label, storedName] : labelMap) {
				if (QString::fromStdString(storedName) == name) return true;
		}

		return false;
}

void MainWindow::onClearUsers() {
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "ëª¨ë“  ì‚¬ìš©ì ì‚­ì œ", "ëª¨ë“  ë“±ë¡ëœ ì‚¬ìš©ì ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                  QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::Yes) {
        clearAllUserData();
        ui->statusbar->showMessage("ëª¨ë“  ì‚¬ìš©ì ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
}


void MainWindow::clearAllUserData()
{
		// Delete face images
		for (const auto& entry : fs::directory_iterator(USER_FACES_DIR)) {
				if(entry.path().filename().string().find("face_") == 0) {
						fs::remove(entry.path());
				}
		}

		// Delete label map
		if (access(USER_LABEL_FILE, F_OK) == 0) {
				cout << "[" << __func__ << "] Clear user data file!!!" << endl;
				fs::remove(USER_LABEL_FILE);
				ifstream file(USER_LABEL_FILE);
				file.close();
		}

		// Delete memory
		storedFaces.clear();
		labelMap.clear();

		cout << "User data is initialized!!!" << endl;
}

MainWindow::~MainWindow() {
    cap.release();  // ì¹´ë©”ë¼ ì¢…ë£Œ
    delete ui;
}

int MainWindow::getNextLabel() {
		// label.txtì—ì„œ ë§ˆì§€ë§‰ ë¼ë²¨ ì½ê¸°
		ifstream ifs(USER_LABEL_FILE);
		
		// if not exist label.txt, Label.txt be create to /usr/local/etc/face_doorlock
		if (!access(USER_LABEL_FILE, F_OK) == 0) {
				ifstream file(USER_LABEL_FILE);
				file.close();
		}
	

		int maxLabel = 0;

		if (ifs.is_open()) {
				int lbl;
				string name;
				while (ifs >> lbl >> name) {
						//cout << "name: " << name << ",  label: " << lbl << endl;
						if (lbl > maxLabel) maxLabel = lbl;
				}

		}

		return maxLabel + 1;
}

void MainWindow::loadLabelMap() 
{
		int rc = 0;

		ifstream ifs(USER_LABEL_FILE);

		rc = Utile::checkFileExist(USER_LABEL_FILE, R_OK + W_OK);
		if (rc == -1) {
				rc = Utile::createFile(USER_LABEL_FILE, R_OK + W_OK);
				if (rc == -1) {
						Logger::writef("[%s] Failed to create file(%s)\n", __func__, USER_LABEL_FILE);		
						exit(1);
				}
		}

		if (ifs.is_open()) {
				int lbl;
				string name;

				while (ifs >> lbl >> name) {
						labelMap[lbl] = name;
				}
		}
}

void MainWindow::saveLabelToFile(int label, const string &name) {
		//if (access(USER_LABEL_FILE, F_OK) == 0) {
				ofstream ofs (USER_LABEL_FILE, ios::app);
				if (ofs.is_open()) ofs << label << " " << name << endl;
		//}
}
	
// ì‚¬ìš©ë˜ê³  ìˆì§€ ì•ŠìŒ
double MainWindow::getAverageSimilarity(const vector<Mat>& samples, const Mat& target)
{
		double total = 0;
		int histSize = 256;										// íˆìŠ¤í† ê·¸ë¨ í¬ê¸°
		float range[] = {0, 256};							// í”½ì…€ ê°’ ë²”ìœ„
		const float* histRange[] = {range};		// í¬ì¸í„° ë°°ì—´ë¡œ ë„˜ê¸°ê¸°	

		for (const auto& sample : samples) {
				Mat hist1, hist2;

				// sample ì´ë¯¸ì§€ íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
				calcHist(&sample, 1, 0, Mat(), hist1, 1, &histSize, histRange, true, false);
				normalize(hist1, hist1, 0, 1, NORM_MINMAX);

				// target ì´ë¯¸ì§€ íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
				calcHist(&target, 1, 0, Mat(), hist2, 1, &histSize, histRange, true, false);
				normalize(hist2, hist2, 0, 1, NORM_MINMAX);

				 // ë‘ íˆìŠ¤í† ê·¸ë¨ì„ ë¹„êµ
				total += compareHist(hist1, hist2, HISTCMP_CORREL);
		}

		return samples.empty() ? -1.0 : total / samples.size();
}

void MainWindow::onRegisterFace() 
{
		if (isRegistering) return;

		userName = QInputDialog::getText(this, "ì‚¬ìš©ì ë“±ë¡", "ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:");
		if (userName.isEmpty()) return;

		if (isUserNameExists(userName)) {
				QMessageBox::warning(this, "ì¤‘ë³µ ì‚¬ìš©ì", "ì´ë¯¸ ë“±ë¡ëœ ì‚¬ìš©ì ì´ë¦„ì…ë‹ˆë‹¤.");
				return;
		}

		currentLabel = getNextLabel();
		captureCount = 0;
		isRegistering = true;
		ui->statusbar->showMessage("[ë“±ë¡ ì¤‘]" + userName + ": 0/20");
}

void MainWindow::showUserList() 
{
		QString filePath = QString::fromStdString(USER_LABEL_FILE);
		QFile file(filePath);

		if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
				QMessageBox::warning(this, "ì˜¤ë¥˜",  "label.txt íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
				return;
		}

		QStringList users;
		while (!file.atEnd()) {
				QByteArray line = file.readLine();
				QString str(line);
				QStringList parts = str.trimmed().split(' ');
				if (parts.size() >= 2) {
						users.append(parts[0] + ": " + parts[1]);
				}
		}

		if (users.isEmpty()) {
				QMessageBox::information(this, "ì‚¬ìš©ì ëª©ë¡", "ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.");
		} else {
				 QMessageBox::information(this, "ì‚¬ìš©ì ëª©ë¡", users.join("\n"));
		}
}

void MainWindow::onExitProgram()
{
		QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "í”„ë¡œê·¸ë¨ ì¢…ë£Œ", "í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                  QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::Yes) {
				exit(1);
    }
}

void MainWindow::onShowUserImages()
{
		// Create new QDialog
		QDialog *dialog = new QDialog(this);
		dialog->setWindowTitle("ë“±ë¡ëœ ì‚¬ìš©ì ì´ë¯¸ì§€ ëª©ë¡");

		// Show the image as a QListWidget
		QListWidget *listWidget = new QListWidget(dialog);


    // ğŸ”´ QMapìœ¼ë¡œ ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ì¸ë„¤ì¼ê³¼ ì—°ë™)
    QMap<QListWidgetItem*, cv::Mat> originalImages;

		   // storedFaces ë§µ ìˆœíšŒ
    for (const auto &entry : storedFaces) {
        int label = entry.first;
        const std::vector<cv::Mat> &faces = entry.second;

        for (size_t i = 0; i < faces.size(); ++i) {
            cv::Mat grayFace = faces[i];


            // ğŸ”´  ê·¸ë ˆì´ ì´ë¯¸ì§€ë¥¼ ì»¬ëŸ¬(RGB)ë¡œ ë³€í™˜
            cv::Mat colorFace;
            cv::cvtColor(grayFace, colorFace, cv::COLOR_GRAY2BGR);

            // ğŸ”´  OpenCV Matë¥¼ QImageë¡œ ë³€í™˜
            QImage img(colorFace.data,
                        colorFace.cols,
                        colorFace.rows,
                        static_cast<int>(colorFace.step),
                        QImage::Format_BGR888);

            // ğŸ”´  QPixmapìœ¼ë¡œ ë³€í™˜í•´ì„œ QListWidgetì— ì¶”ê°€
            QPixmap pixmap = QPixmap::fromImage(img).scaled(64, 64, Qt::KeepAspectRatio);
            QListWidgetItem *item = new QListWidgetItem;
            item->setIcon(QIcon(pixmap));
            item->setText(QString("Label: %1 - #%2").arg(label).arg(i));
            listWidget->addItem(item);

            // ğŸ‘‰ ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (ë³µì‚¬!)
            originalImages[item] = colorFace.clone();
        }
    }

		   // ğŸ”´ 2ï¸âƒ£ ì•„ì´í…œ í´ë¦­ ì‹œ í° ì´ë¯¸ì§€ë¡œ ë³´ê¸°
    connect(listWidget, &QListWidget::itemClicked, [=](QListWidgetItem *item){
        // ì›ë³¸ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
        cv::Mat colorFace = originalImages[item];

        // QImage ë³€í™˜
        QImage img(colorFace.data,
                    colorFace.cols,
                    colorFace.rows,
                    static_cast<int>(colorFace.step),
                    QImage::Format_BGR888);

        // ğŸ‘‰ QDialogë¡œ í° ì´ë¯¸ì§€ ë³´ê¸°
        QDialog *imageDialog = new QDialog(dialog);
        imageDialog->setWindowTitle(item->text());

        QLabel *imageLabel = new QLabel(imageDialog);
        imageLabel->setPixmap(QPixmap::fromImage(img).scaled(500, 500, Qt::KeepAspectRatio));

        QVBoxLayout *imageLayout = new QVBoxLayout(imageDialog);
        imageLayout->addWidget(imageLabel);
        imageDialog->setLayout(imageLayout);

        imageDialog->exec();
        delete imageDialog;
    });

    QVBoxLayout *layout = new QVBoxLayout(dialog);
    layout->addWidget(listWidget);
    dialog->setLayout(layout);

    dialog->exec();
    delete dialog;

}

// ì‚¬ìš©ë˜ê³  ìˆì§€ ì•ŠìŒ ë¦¬êµ¬í˜„ì˜ˆì •
bool MainWindow::isDuplicateFace(const Mat& newFace)
{
		if (!faceRecognizer || newFace.empty()) {
        std::cerr << "[ì˜¤ë¥˜] ì–¼êµ´ ì¸ì‹ê¸°ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì…ë ¥ ì´ë¯¸ì§€ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤." << std::endl;
        return false;
    }

    int predictedLabel = -1;
    double confidence = 0.0;

    // ì˜ˆì¸¡ ìˆ˜í–‰ (ì…ë ¥ì€ ë°˜ë“œì‹œ í‘ë°±ì´ì–´ì•¼ í•¨)
    cv::Mat gray;
    if (newFace.channels() == 3)
        cv::cvtColor(newFace, gray, cv::COLOR_BGR2GRAY);
    else
        gray = newFace;

		if (!storedFaces.empty()) {
				faceRecognizer->predict(gray, predictedLabel, confidence);
		}

    std::cout << "ì˜ˆì¸¡ëœ ë¼ë²¨: " << predictedLabel << ", ì‹ ë¢°ë„: " << confidence << std::endl;

    // ì‹ ë¢°ë„ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µ ì—¬ë¶€ íŒë‹¨
    const double DUPLICATE_THRESHOLD = 50.0; // ì‘ì„ìˆ˜ë¡ ì—„ê²© (OpenCV LBPH ê¸°ì¤€ 50~100 ì ì ˆ)

    return (confidence < DUPLICATE_THRESHOLD) && (confidence) && (predictedLabel != -1);
}

Mat MainWindow::alignAndNormalizeFace(const Mat& grayFrame, const Rect& faceRect)
{
		Mat faceROI = grayFrame(faceRect).clone();

		// ëˆˆ ê²€ì¶œ
		vector<Rect> eyes;
		eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 10, 0, Size(20, 20));

		if (eyes.size() < 2) return {};	 // ëˆˆì´ 2ê°œ ë¯¸ë§Œì´ë©´ ì‹¤íŒ¨

		// ëˆˆ 2ê°œë¥¼ ì¢Œ/ìš°ë¡œ ì •ë ¬
		Point eye1 = (eyes[0].x < eyes[1].x) ? eyes[0].tl() : eyes[1].tl();
		Point eye2 = (eyes[0].x < eyes[1].x) ? eyes[1].tl() : eyes[0].tl();

		// ëˆˆ ì¤‘ì‹¬ ê³„ì‚°
		eye1 += Point(eyes[0].width/2, eyes[0].height/2);
		eye2 += Point(eyes[1].width/2, eyes[1].height/2);

		// ê°ë„ ê³„ì‚°
		double dy = eye2.y - eye1.y;
		double dx = eye2.x - eye1.x;
		double angle = atan2(dy, dx) * 180.0 / CV_PI;

		// ì–¼êµ´ ì¤‘ì•™ ê¸°ì¤€ íšŒì „
		Point2f center(faceROI.cols/2.0F, faceROI.rows/2.0F);
		Mat rot = getRotationMatrix2D(center, angle, 1.0);

		Mat aligned;
		warpAffine(faceROI, aligned, rot, faceROI.size());

		// ë°ê¸° ë³´ì • + í¬ê¸° ì¡°ì •
		equalizeHist(aligned, aligned);
		cv::resize(aligned, aligned, Size(200, 200));

		//cout << "[" << __func__ << "] Face is aligned and normalized!!" << endl;
		return aligned;
}

void MainWindow::updateFrame() {
    Mat frame, gray;
		Mat faceColor;

    cap >> frame;
    if (frame.empty()) return;

		// ì–¼êµ´ ì¸ì‹ìš© í‘ë°± ì´ë¯¸ì§€ ìƒì„±
    cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
		equalizeHist(gray, gray);

		// ì–¼êµ´ íƒì§€
		vector<Rect> faces;
		faceCascade.detectMultiScale(
				gray, faces,
				1.1,					// scaleFactor: ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©° íƒì§€ (1.1~1.3 ì¶”ì²œ)					
				5,						// minNeighbors: ìµœì†Œ ì´ì›ƒ ìˆ˜ (ê°’ì´ ë†’ì„ìˆ˜ë¡ ì •ë°€, 3~6 ì¶”ì²œ)
				CASCADE_SCALE_IMAGE,
				Size(100, 100) // ìµœì†Œ ì–¼êµ´ í¬ê¸° ì„¤ì • (ë„ˆë¬´ ì‘ìœ¼ë©´ false positive ë°œìƒ)			
		);

		for (const auto& face : faces) {

				faceColor = frame(face);
				Mat alignedFace = alignAndNormalizeFace(gray, face);
				if (alignedFace.empty()) continue;

				//Mat faceROI = gray(face);
				//cv::resize(faceROI, faceROI, Size(200, 200));

/*
				// ì–¼êµ´ ì˜ì—­ì—ì„œ ëˆˆ ê²€ì¶œ
				vector<Rect> eyes;
				eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 10, 0, cv::Size(20, 20));
				if (eyes.size() < 2) continue; // ëˆˆì´ 2ê°œ ë¯¸ë§Œì´ë©´ false positive ì œê±°
				// ëˆˆë„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ê³  ì‹¶ìœ¼ë©´ ì¶”ê°€
				for (const auto& eye : eyes) {
						cv::Point eyeCenter(face.x + eye.x + eye.width / 2, face.y + eye.y + eye.height / 2);
						int radius = cvRound((eye.width + eye.height) * 0.25);
						cv::circle(frame, eyeCenter, radius, cv::Scalar(255, 0, 0), 2);
				}
*/
				QString labelText;
				Scalar boxColor;


				if (!isRegistering) {
						// ë“±ë¡ ëª¨ë“œê°€ ì•„ë‹ ë•Œ ë“±ë¡ëœ ì‚¬ìš©ìì™€ ë¹„êµ
						int predictedLabel = -1;
						double confidence = 999.0;

						if (!storedFaces.empty()) {
								faceRecognizer->predict(alignedFace, predictedLabel, confidence);
						}

						//cout << "[" << __func__ << "] predictedLabel: " << predictedLabel << "confidence: " << confidence << endl; 
						if (confidence < 60.0 && labelMap.count(predictedLabel)) {
								labelText = QString::fromStdString(labelMap[predictedLabel]);
								boxColor = Scalar(0, 255, 0);
						}
						else {
								labelText = "Unknown";
								boxColor= Scalar(0, 0, 255);
						}
						rectangle(frame, face, boxColor, 2);

						putText(frame, labelText.toStdString(), Point(face.x + 100, face.y + face.height + 20),
										FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);
				}
				else if (isRegistering) {
						labelText = "Registering...";
						boxColor = Scalar(255, 0, 0);

						rectangle(frame, face, Scalar(255, 0, 0), 2);
						putText(frame, labelText.toStdString(), Point(face.x, face.y + face.height + 20),
										FONT_HERSHEY_SIMPLEX, 0.8, boxColor, 2);

						//rectangle(frame, cv::Rect(0, 0, frame.cols - 1, frame.rows - 1), Scalar(0, 255, 0), 4);

						if (captureCount == 0 && isDuplicateFace(alignedFace)) {
								ui->statusbar->showMessage("ì´ë¯¸ ë“±ë¡ëœ ì–¼êµ´ì…ë‹ˆë‹¤.");
								isRegistering = false;
								return;
						}

						if (captureCount < 20) {
								if (!fs::exists(USER_FACES_DIR)) 
										fs::create_directory(USER_FACES_DIR);

								string filename = CONF_PATH + string("data/face_") + to_string(currentLabel) + "_" + to_string(captureCount + 1) + ".png";
								//if (!imwrite(filename, alignedFace)) {
								if (!imwrite(filename, faceColor)) {
									qDebug() << "ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨: " << QString::fromStdString(filename);
								}
								colorStoredFaces[currentLabel].push_back(faceColor);
								storedFaces[currentLabel].push_back(alignedFace);
								labelMap[currentLabel] = userName.toStdString();
								captureCount++;
								ui->statusbar->showMessage(QString("[ë“±ë¡ì¤‘] %1: %2/20").arg(userName).arg(captureCount));
								if (captureCount >= 20) {
										saveLabelToFile(currentLabel, userName.toStdString());

										vector<Mat> images;
										vector<int> labels;
										for (const auto& entry : storedFaces) {
												for (const auto& img : entry.second) {
														images.push_back(img);
														labels.push_back(entry.first);
												}
										}

										faceRecognizer->train(images, labels);
										isRegistering = false;
										ui->statusbar->showMessage("[ë“±ë¡ ì™„ë£Œ]" + userName);
								}
						}

										}

				//cv::cvtColor(frame, frame, cv::COLOR_BGR2RGB);
				QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_BGR888);
				ui->cameraLabel->setPixmap(QPixmap::fromImage(qimg));
		}

		cvtColor(frame, frame, COLOR_BGR2RGB);
    //QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_BGR888);
    QImage qimg(frame.data, frame.cols, frame.rows, frame.step, QImage::Format_RGB888);
    ui->cameraLabel->setPixmap(QPixmap::fromImage(qimg));
}
